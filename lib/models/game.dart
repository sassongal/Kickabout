import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:kattrick/models/enums/game_status.dart';
import 'package:kattrick/models/enums/game_visibility.dart';
import 'package:kattrick/models/converters/timestamp_converter.dart';
import 'package:kattrick/models/converters/geopoint_converter.dart';
import 'package:kattrick/models/team.dart';
import 'package:kattrick/models/targeting_criteria.dart';
import 'package:kattrick/models/game_denormalized_data.dart';
import 'package:kattrick/models/game_session.dart';
import 'package:kattrick/models/game_audit.dart';

part 'game.freezed.dart';
part 'game.g.dart';

/// Game model matching Firestore schema: /games/{gameId}
@freezed
class Game with _$Game {
  const factory Game({
    required String gameId,
    required String createdBy,
    String? hubId, // Nullable for public pickup games
    String?
        eventId, // ID of the event this game belongs to (required for new games, optional for legacy)
    @TimestampConverter() required DateTime gameDate,
    String? location, // Legacy text location
    @NullableGeoPointConverter()
    GeoPoint? locationPoint, // New geographic location
    String? geohash,
    String? venueId, // Reference to venue
    @Default(2) int teamCount, // 2, 3, or 4
    @GameStatusConverter() @Default(GameStatus.teamSelection) GameStatus status,
    @GameVisibilityConverter()
    @Default(GameVisibility.private)
    GameVisibility visibility, // private, public, or recruiting
    TargetingCriteria? targetingCriteria,
    @Default(false) bool requiresApproval,
    @Default(10) int minPlayersToPlay,
    int? maxPlayers,
    @Default([]) List<String> photoUrls,
    @TimestampConverter() required DateTime createdAt,
    @TimestampConverter() required DateTime updatedAt,
    // Recurring game fields
    @Default(false) bool isRecurring,
    String? parentGameId,
    String? recurrencePattern,
    @NullableTimestampConverter() DateTime? recurrenceEndDate,
    // Teams
    @Default([]) List<Team> teams, // Teams created in TeamMaker
    // Game rules
    int? durationInMinutes,
    String? gameEndCondition,
    String? region,
    String? city,
    // Community feed
    @Default(false) bool showInCommunityFeed,
    // Attendance
    @Default(true) bool enableAttendanceReminder,
    bool? reminderSent2Hours,
    DateTime? reminderSent2HoursAt,
    // Sub-models
    @Default(GameDenormalizedData()) GameDenormalizedData denormalized,
    @Default(GameSession()) GameSession session,
    @Default(GameAudit()) GameAudit audit,
  }) = _Game;

  // Private constructor needed for custom methods
  const Game._();

  /// Factory constructor from Firestore - applies migration from flat to nested structure
  factory Game.fromFirestore(Map<String, dynamic> json) {
    final migratedJson = _migrateGameJson(json);
    return Game.fromJson(migratedJson);
  }

  /// Standard JSON deserialization (generated by freezed)
  factory Game.fromJson(Map<String, dynamic> json) => _$GameFromJson(json);

  // ============================================================================
  // BUSINESS LOGIC METHODS
  // ============================================================================

  // Status predicates
  /// Whether the game is upcoming (team selection or teams formed)
  bool get isUpcoming => status == GameStatus.teamSelection || status == GameStatus.teamsFormed;

  /// Whether the game is currently active/in progress
  bool get isActive => status == GameStatus.inProgress;

  /// Whether the game has been completed
  bool get isCompleted => status == GameStatus.completed;

  /// Whether the game has been cancelled
  bool get isCancelled => status == GameStatus.cancelled;

  /// Whether the game date is in the past
  bool get isPast => gameDate.isBefore(DateTime.now());

  // Participant management
  /// Total number of participants across all teams
  int get totalParticipants => teams.fold(0, (sum, team) => sum + team.playerIds.length);

  /// Whether the game has reached maximum player capacity
  bool get isFull => maxPlayers != null && totalParticipants >= maxPlayers!;

  /// Whether the game has minimum players required to play
  bool get hasMinimumPlayers => totalParticipants >= minPlayersToPlay;

  /// Check if a player can be added to the game
  ///
  /// Returns false if:
  /// - Game is full
  /// - Game is completed or cancelled
  /// - User is already in a team
  bool canAddPlayer(String userId) {
    if (isFull) return false;
    if (isCompleted || isCancelled) return false;
    return !teams.any((team) => team.playerIds.contains(userId));
  }

  // Time helpers
  /// Duration until the game starts
  Duration get timeUntilGame => gameDate.difference(DateTime.now());

  /// Whether the game is within 24 hours
  bool get isWithin24Hours => timeUntilGame.inHours <= 24 && timeUntilGame.inHours >= 0;

  /// Formatted time until game in Hebrew
  String get timeUntilDisplay {
    if (isPast) return 'עבר';
    final duration = timeUntilGame;
    if (duration.inDays > 0) return '${duration.inDays} ימים';
    if (duration.inHours > 0) return '${duration.inHours} שעות';
    return '${duration.inMinutes} דקות';
  }
}

/// Migrates legacy flat Game JSON structure to new nested structure
Map<String, dynamic> _migrateGameJson(Map<String, dynamic> json) {
  // If already has nested structure, return as-is
  if (json.containsKey('denormalized') &&
      json.containsKey('session') &&
      json.containsKey('audit')) {
    return json;
  }

  final result = Map<String, dynamic>.from(json);

  // 1. Migrate Denormalized Data
  final denormalizedJson = json['denormalized'] as Map<String, dynamic>? ?? {};
  final hasDenormalized = json.containsKey('denormalized');

  if (!hasDenormalized) {
    final migratedDenormalized = <String, dynamic>{};

    if (json.containsKey('createdByName')) {
      migratedDenormalized['createdByName'] = json['createdByName'];
    }
    if (json.containsKey('createdByPhotoUrl')) {
      migratedDenormalized['createdByPhotoUrl'] = json['createdByPhotoUrl'];
    }
    if (json.containsKey('hubName')) {
      migratedDenormalized['hubName'] = json['hubName'];
    }
    if (json.containsKey('venueName')) {
      migratedDenormalized['venueName'] = json['venueName'];
    }
    if (json.containsKey('goalScorerIds')) {
      migratedDenormalized['goalScorerIds'] = json['goalScorerIds'];
    }
    if (json.containsKey('goalScorerNames')) {
      migratedDenormalized['goalScorerNames'] = json['goalScorerNames'];
    }
    if (json.containsKey('mvpPlayerId')) {
      migratedDenormalized['mvpPlayerId'] = json['mvpPlayerId'];
    }
    if (json.containsKey('mvpPlayerName')) {
      migratedDenormalized['mvpPlayerName'] = json['mvpPlayerName'];
    }
    if (json.containsKey('confirmedPlayerIds')) {
      migratedDenormalized['confirmedPlayerIds'] = json['confirmedPlayerIds'];
    }
    if (json.containsKey('confirmedPlayerCount')) {
      migratedDenormalized['confirmedPlayerCount'] = json['confirmedPlayerCount'];
    }
    if (json.containsKey('isFull')) {
      migratedDenormalized['isFull'] = json['isFull'];
    }
    if (json.containsKey('maxParticipants')) {
      migratedDenormalized['maxParticipants'] = json['maxParticipants'];
    }

    result['denormalized'] = migratedDenormalized;
  } else {
    result['denormalized'] = denormalizedJson;
  }

  // 2. Migrate Session Data
  final sessionJson = json['session'] as Map<String, dynamic>? ?? {};
  final hasSession = json.containsKey('session');

  if (!hasSession) {
    final migratedSession = <String, dynamic>{};

    if (json.containsKey('matches')) {
      migratedSession['matches'] = json['matches'];
    }
    if (json.containsKey('aggregateWins')) {
      migratedSession['aggregateWins'] = json['aggregateWins'];
    }
    if (json.containsKey('teamAScore')) {
      migratedSession['legacyTeamAScore'] = json['teamAScore'];
    }
    if (json.containsKey('teamBScore')) {
      migratedSession['legacyTeamBScore'] = json['teamBScore'];
    }

    result['session'] = migratedSession;
  } else {
    result['session'] = sessionJson;
  }

  // 3. Migrate Audit Data
  final auditJson = json['audit'] as Map<String, dynamic>? ?? {};
  final hasAudit = json.containsKey('audit');

  if (!hasAudit) {
    final migratedAudit = <String, dynamic>{};

    if (json.containsKey('auditLog')) {
      migratedAudit['auditLog'] = json['auditLog'];
    }

    result['audit'] = migratedAudit;
  } else {
    result['audit'] = auditJson;
  }

  return result;
}

/// Firestore converter for Game
class GameConverter implements JsonConverter<Game, Map<String, dynamic>> {
  const GameConverter();

  @override
  Game fromJson(Map<String, dynamic> json) {
    // Migration is handled automatically in Game.fromJson
    return Game.fromJson(json);
  }

  @override
  Map<String, dynamic> toJson(Game object) {
    // Write nested structure
    // We do NOT flatten on write. This is a one-way migration to better structure.
    return object.toJson();
  }
}

/// GameStatus converter for Firestore
class GameStatusConverter implements JsonConverter<GameStatus, String> {
  const GameStatusConverter();

  @override
  GameStatus fromJson(String json) => GameStatus.fromFirestore(json);

  @override
  String toJson(GameStatus object) => object.toFirestore();
}

// ignore_for_file: invalid_annotation_target
